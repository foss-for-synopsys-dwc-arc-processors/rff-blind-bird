import os, getopt, sys
from termcolor import colored


RFF_BB_VERSION = "20190411.0.0.1"


default_args = [
    { "name" : "cause",  "size" : 4, "used" : True,  "fmt" : '{:#010x}' },
    { "name" : "stat32", "size" : 4, "used" : True,  "fmt" : '{:#010x}' },
    { "name" : "pc",     "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "efa",    "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "extra",  "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "task",   "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "sp",     "size" : 4, "used" : True,  "fmt" : '{:#x}' }
]

# common case for snap2 - address and size
adr_sz_snap2_args = [
    { "name" : "adr",    "size" : 4, "used" : True,  "fmt" : '{:#010x}' },
    { "name" : "size",   "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "pc",     "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "--",     "size" : 4, "used" : False, "fmt" : '{:#x}' },
    { "name" : "--",     "size" : 4, "used" : False, "fmt" : '{:#x}' },
    { "name" : "task",   "size" : 4, "used" : True,  "fmt" : '{:#x}' },
    { "name" : "sp",     "size" : 4, "used" : True,  "fmt" : '{:#x}' }
]

timeline_log_t = [
    { "name" : "cpu",    "size" : 4, "used" : True, "fmt" : '{:1d}' },
    { "name" : "time",   "size" : 4, "used" : True, "fmt" : '{:10d}' },
    { "name" : "event",  "size" : 4, "used" : True, "enum-map" :
        {
            # Don't touch - it's autogenerated from "event-log.h of 4.15 event logger,
            # commit d1bc3e5c6f501371f917dda024cdffd80c39ec90 (ARC: Low level Event logger)"
            ((0 << 8)|0x01)  : { "name" : "IRQ_I" },
            ((0 << 8)|0x02)  : { "name" : "IRQ_O" },
            ((1 << 8)|0x01)  : { "name" : "EX_I" },
            ((1 << 8)|0x02)  : { "name" : "EX_O" },
            ((2 << 8)|0x01)  : { "name" : "SYSCALL" },
            ((2 << 8)|0x02)  : { "name" : "TRAP_O" },
            ((0 << 8)|0x80)  : { "name" : "SW_U" },
            ((1 << 8)|0x80)  : { "name" : "SW_K" },
            ((4 << 8)|0x01)  : { "name" : "ITLB" },
            ((5 << 8)|0x01)  : { "name" : "DITLB_Miss_ld" },
            ((6 << 8)|0x01)  : { "name" : "DTLB_Miss_st" },
            ((7 << 8)|0x01)  : { "name" : "ProtV" },
            ((7 << 8)|0x80)  : { "name" : "TLB_slow" },
            ((8 << 8)|0x80)  : { "name" : "TLB_FAST" },
            ((3 << 8)|0x80)  : { "name" : "PREEMPT_I" },
            ((6 << 8)|0x80)  : { "name" : "EXIT" },
            ((2 << 8)|0x80)  : { "name" : "TLB_Flush" },
            ((9 << 8)|0x80)  : { "name" : "IPI_sent" },
            ((10 << 8)|0x80) : { "name" : "ipi_elide" },
            ((11 << 8)|0x80) : { "name" : "dma_ALLOC", "args-interpr" : adr_sz_snap2_args },
            ((12 << 8)|0x80) : { "name" : "dma_free" },
            ((16 << 8)|0x80) : { "name" : "cache_wb_inv", "args-interpr" : adr_sz_snap2_args },
            ((15 << 8)|0x80) : { "name" : "cache_wb", "args-interpr" : adr_sz_snap2_args },
            ((14 << 8)|0x80) : { "name" : "cache_inv", "args-interpr" : adr_sz_snap2_args },
            ((17 << 8)|0x80) : { "name" : "MEMSET", "args-interpr" : adr_sz_snap2_args },
            ((18 << 8)|0x80) : { "name" : "MEMCPY" }
        },
        # default interpreter
        "args-interpr" : default_args
    }
]


colorizer_function = colored
split_tab = "; "


def no_color(str, color, attrs=[]):
    return str


def color_header(str):
    return colorizer_function(str, 'white', attrs=['dark'])


def color_value(str):
    return colorizer_function(str, 'green')


def color_idx(str):
    return colorizer_function(str, 'red')


def color_idx_highlight(str):
    return colorizer_function(str, 'blue')


def logbuf_entry_size(log_t):
    entry_size = 0;

    for var in log_t:
        entry_size += var["size"]
        if "args-interpr" in var:
            entry_size += logbuf_entry_size(var["args-interpr"])

    return entry_size


def entry_var_to_string(var, value, fi):
    enrty_header = color_header(var["name"] + ": ")
    enrty_interpretrd = ""
    subentry = ""
    enrty_var = int.from_bytes(value, byteorder='little')
    if not var["used"]:
        return ""
    # simple formater - int / hex / bin / octal
    if "fmt" in var:
        enrty_interpretrd += str(var["fmt"].format(enrty_var))
    # enum formater, may hav args attached
    elif "enum-map" in var:
        if enrty_var in var["enum-map"]:
            enrty_interpretrd += str(var["enum-map"][enrty_var]["name"])
            if "args-interpr" in var:
                subentry += split_tab
                if "args-interpr" in var["enum-map"][enrty_var]:
                    # we have custom interpreter
                    subentry += process_entry(var["enum-map"][enrty_var]["args-interpr"], fi)
                else:
                    # use default one
                    subentry += process_entry(var["args-interpr"], fi)
        else:
            enrty_interpretrd += "??? (" + hex(enrty_var) + ")"
            if "args-interpr" in var:
                subentry += split_tab
                # for unknown entry we definitely don't have custom interpreter
                # so use default one
                subentry += process_entry(var["args-interpr"], fi)

    return enrty_header + color_value(enrty_interpretrd) + subentry


def process_entry(log_t, fi):
    global split_tab
    enrty_interpretrd = ""
    last = len(log_t)

    for i, var in enumerate(log_t):
        memory_value = fi.read(var["size"])
        if not memory_value:
            return ""

        curr_entry = entry_var_to_string(var, memory_value, fi)
        enrty_interpretrd += curr_entry

        # don't print the separator after the last enrty or if entry is unused (empty)
        if i + 1 != last and curr_entry:
            enrty_interpretrd += split_tab

    return enrty_interpretrd


def process_entries(log_t, fi, id_start, id_end, id_point):
    entry_id = id_start;

    if id_end < id_start:
        return

    seek_size = logbuf_entry_size(timeline_log_t) * id_start
    fi.seek(seek_size)

    while (True):
        enrty_interpretrd = process_entry(timeline_log_t, fi)
        if not enrty_interpretrd:
            break

        if entry_id == id_point:
            print(color_idx_highlight('[{:6d}] '.format(entry_id)) + enrty_interpretrd)
        else:
            print(color_idx('[{:6d}] '.format(entry_id)) + enrty_interpretrd)

        if entry_id > id_end:
            break

        entry_id += 1


def usage(exit_code):
    print(sys.argv[0] + " version: " + RFF_BB_VERSION)
    print("usage:")
    print(" " + sys.argv[0] + " --input time-log-mem.txt")
    print(" " + sys.argv[0] + " --start 418000 --end 419920 --curr 419903 --input time-log-mem.txt --tab= --color")
    print(" " + sys.argv[0] + " --curr 100 --input time-log-mem.txt --tab= --color")
    print("options:")
    print(" --input <filename> - file with buffer to open")
    print(" --tab <separator> - use <separator> to split the coloms.\n" \
          "   Default is \"; \"\n" \
          "   If used blank (--tab=) the tabs are used.")
    print(" --start <idx> - don't display buffer values before <idx>")
    print(" --end <idx> - don't display buffer values after <idx>")
    print(" --curr <idx> - highlight current index with color <idx>")
    print(" --align <num> - skip <idx> bytes from the beggining of the file.\n" \
          "   Useful in case bad-captured buffer.")
    print(" --color - force output colorizing")
    sys.exit(exit_code)


def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hs:e:c:i:t:a:l",
            ["help", "start=", "end=", "curr=", "input=", "tab=", "align=", "color"])
    except getopt.GetoptError as err:
        print(err)

    global colorizer_function
    global split_tab

    id_start = 0
    id_end   = 10000000
    id_point = 0
    file_to_parse = "time-log-mem.txt"
    align_cut = 0

    if not sys.stdout.isatty():
        colorizer_function = no_color

    for opt, arg in opts:
        if opt in ('-h', "--help"):  usage(0)
        if opt in ('-l', "--color"):  colorizer_function = colored
        if opt in ('-s', "--start"): id_start  = int(arg, 10)
        if opt in ('-e', "--end"):   id_end    = int(arg, 10)
        if opt in ('-c', "--curr"):  id_point  = int(arg, 10)
        if opt in ('-i', "--input"): file_to_parse = arg
        if opt in ('-t', "--tab"):   split_tab = arg
        if opt in ('-a', "--align"): align_cut  = int(arg, 10)

    if not split_tab:
        split_tab = "\t"

    with open(file_to_parse,'rb') as fi:
        if align_cut:
            fi.seek(align_cut)
        process_entries(timeline_log_t, fi, id_start, id_end, id_point)


if __name__ == "__main__":
    try:
        main()
    except Exception as err:
        print(err)
        sys.exit(2)
